#include <assert.h>
#include <SDL/SDL.h>
#include <stdint.h>
#include <math.h>
#include "cga.h"
#include "sdl_common.h"

#define CGA_FONT_THIN	0
#define CGA_FONT_THICK	1

/* The full internal CGI 16-color palette. */
static SDL_Color cga_palette[16] = {
	{ 0x00, 0x00, 0x00, 0x00 },	{ 0x00, 0x00, 0xAA, 0x00 },
	{ 0x00, 0xAA, 0x00, 0x00 },	{ 0x00, 0xAA, 0xAA, 0x00 },
	{ 0xAA, 0x00, 0x00, 0x00 },	{ 0xAA, 0x00, 0xAA, 0x00 },
	{ 0xAA, 0x55, 0x00, 0x00 },	{ 0xAA, 0xAA, 0xAA, 0x00 },
	{ 0x55, 0x55, 0x55, 0x00 },	{ 0x55, 0x55, 0xFF, 0x00 },
	{ 0x55, 0xFF, 0x55, 0x00 },	{ 0x55, 0xFF, 0xFF, 0x00 },
	{ 0xFF, 0x55, 0x55, 0x00 },	{ 0xFF, 0x55, 0xFF, 0x00 },
	{ 0xFF, 0xFF, 0x55, 0x00 },	{ 0xFF, 0xFF, 0xFF, 0x00 }
};
const int cga_palette_entries = 16;

/* prototypes */
uint8_t cga_font_thick[];
uint8_t cga_font_thin[];
void __cga_load_fonts(struct cga_context *cga);

static inline void
__cga_map_location(struct cga_context *cga, int loc, int *x, int *y)
{
	const int pitch = 80;	/* CGA pitch is 80 bytes in all modes */

	assert(cga != NULL);
	assert(x != NULL && y != NULL);
	assert((loc >= 0 && loc < 0x1F30) || (loc >= 0x2000 && loc < 0x3E80));

	*x = (loc % 0x2000 % pitch) * 4;
	*y = (loc % 0x2000 / pitch) * 2 + (loc >= 0x2000);
}

static inline int
__surface_set_palette(struct SDL_Surface *surface,
                      SDL_Color background_color, int palette, int intensity)
{
	SDL_Color colors[4];

	assert(surface != NULL);
	assert(palette == CGA_PALETTE_0 || palette == CGA_PALETTE_1);
	assert(intensity == CGA_INTENSITY_NORMAL || intensity == CGA_INTENSITY_HIGH);

	colors[0] = background_color;
	colors[1] = cga_palette[intensity + palette + 2];
	colors[2] = cga_palette[intensity + palette + 4];
	colors[3] = cga_palette[intensity + palette + 6];

	return SDL_SetColors(surface, colors, 0, 4);
}

static inline int __cga_set_palette(struct cga_context *cga)
{
	return __surface_set_palette(cga->surface, cga->background_color,
	                             cga->palette, cga->intensity);
}

static inline SDL_Surface *__cga_create_surface(struct cga_context *cga)
{
	int w, h;

	assert(cga != NULL);

	switch (cga->mode) {
	case CGA_MODE_TEXT_40x25:
	case CGA_MODE_GRAPHICS_320x200:
		w = 320, h = 200;
		break;
	case CGA_MODE_TEXT_80x25:
	case CGA_MODE_GRAPHICS_640x200:
		w = 640, h = 200;
		break;
	default:
		return NULL;
	}

	return SDL_CreateRGBSurface(SDL_HWSURFACE, w, h, 8, 0, 0, 0, 0);
}

/* Poke a raw image directly onto a surface.  Does not clip. */
static void
__surface_poke_image(SDL_Surface *surface, struct cga_image_raw *raw, int x, int y)
{
	uint8_t *data = raw->data;
	uint8_t *pixel;
	int i, j;

	assert(raw);
	assert(surface);
	assert(surface->w >= raw->width);
	assert(surface->h >= raw->height);
	assert(surface->format->BitsPerPixel == 8);
	assert(raw->size != 0);
	assert(raw->size == raw->height * raw->width / 4);
	assert(x >= 0 && x <= surface->w - raw->width);
	assert(y >= 0 && y <= surface->h - raw->height);

	if (SDL_MUSTLOCK(surface))
		SDL_LockSurface(surface);

	pixel = surface->pixels + x + y * surface->pitch;

	for (i = 0; i < raw->height; i++) {
		for (j = 0; j < raw->width / 4; j++, data++, pixel += 4) {
			pixel[0] = (*data >> 6) & 0x3;
			pixel[1] = (*data >> 4) & 0x3;
			pixel[2] = (*data >> 2) & 0x3;
			pixel[3] = (*data >> 0) & 0x3;
		}

		/* Handle remainder bits */
		switch(raw->width % 4) {
		case 3:
			*pixel++ = (*data >> 6) & 0x3;
		case 2:
			*pixel++ = (*data >> 4) & 0x3;
		case 1:
			*pixel++ = (*data++ >> 2) & 0x3;
		}

		pixel += surface->pitch -
		         raw->width * surface->format->BytesPerPixel;
	}

	if (SDL_MUSTLOCK(surface))
		SDL_UnlockSurface(surface);
}


/* Create the fontset in hardware memory for fast blitting, and initialize
 * the rest of the CGA video context.
 *
 * If this function fails, do not make assumptions about the content of struct
 * cga_context.
 */
int cga_init(struct cga_context *cga, int mode, SDL_Surface *cga_surface)
{
	SDL_Surface *s;

	assert(cga != NULL);

	/* Create a hardware surface for the fontset we use. */
	s = SDL_CreateRGBSurface(SDL_HWSURFACE, 128, 128, 8, 0, 0, 0, 0);
	if (s == NULL)
		return -1;

	/* If we have a surface argument, use that surface.  Otherwise create
	 * our own surface.
	 * We initialize parts of the CGA context that will be used by
	 * cga_set_surface().
	 */
	cga->mode = mode;
	cga->surface = NULL;
	cga->palette = CGA_PALETTE_0;
	cga->intensity = CGA_INTENSITY_NORMAL;
	cga->background_color = cga_palette[0];

	if (cga_surface != NULL) {
		if (cga_set_surface(cga, cga_surface) == -1)
			goto err;
	} else {
		cga->surface = __cga_create_surface(cga);
		if (cga->surface == NULL)
			goto err;

		/* cga_set_surface() already initializes the palette */
		if (__cga_set_palette(cga) != 1)
			goto err2;
	}

	/* CGA font settings */
	cga->fonts = s;
	/* CGA defaults to thick fonts; the thin one doesn't show up well. */
	cga->font_type = CGA_FONT_THICK;
	cga->font_color = 0;
	cga->cursor_pos.x = 0;
	cga->cursor_pos.y = 0;
	cga->cursor_pos.w = 0;
	cga->cursor_pos.h = 0;

	__cga_load_fonts(cga);
	return 0;

err2:
	if (cga_surface == NULL)
		SDL_FreeSurface(cga->surface);
	else
		cga->surface->refcount--;
err:
	SDL_FreeSurface(s);

	return -1;
}

int cga_set_surface(struct cga_context *cga, SDL_Surface *surface)
{
	assert(cga != NULL);
	assert(surface != NULL);

	/* We expect a palettized surface. */
	if (surface->format->BitsPerPixel != 8)
		return -1;

	/* Check wether the selected cga mode corresponds with the surface. */
	switch(cga->mode) {
	case CGA_MODE_TEXT_40x25:
	case CGA_MODE_GRAPHICS_320x200:
		if (surface->w != 320 || surface->h != 200)
			return -1;
		break;
	case CGA_MODE_TEXT_80x25:
	case CGA_MODE_GRAPHICS_640x200:
		if (surface->w != 640 || surface->h != 200)
			return -1;
		break;
	default:
		return -1;
	}

	/* We can use this surface, replace the old one. */
	if (cga->surface != NULL)
		SDL_FreeSurface(cga->surface);
	cga->surface = surface;

	if (__cga_set_palette(cga) != 1)
		return -1;

	cga->surface->refcount++;
	return 0;
}

/* The cga_peek_* and cga_poke_* functions provide low-level access to the
 * CGA video memory buffers at 0xB800:offset.
 *
 * They can be used to read and write raw CGA video memory data as used on
 * original CGA controllers and have it handled properly.
 * As these are low-level access routines, they should be used by people with
 * half a brain.  The API does not perform overflow checking for instance.
 *
 * Note that this behaviour is emulated, so it will lock the CGA surface and
 * poke pixel data directly, losing efficiency of hardware blitting.  If
 * hardware blitting is needed, use the higher level cga_blit_* functions.
 *
 * cga_poke_byte() pokes a single byte to video memory.
 * cga_peek_byte() peeks a single byte from video memory.
 * cga_poke_bytes() pokes a range of bytes to video memory.
 * cga_poke_word() pokes a word to video memory.
 * cga_poke_words() pokes a range of words to video memory.
 * cga_poke_image() pokes raw image data of given dimensions to video memory.
 */
void cga_poke_byte(struct cga_context *cga, int loc, uint8_t byte)
{
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);
	assert(cga->surface != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	*pixel++ = (byte >> 6) & 0x3;
	*pixel++ = (byte >> 4) & 0x3;
	*pixel++ = (byte >> 2) & 0x3;
	*pixel++ = (byte >> 0) & 0x3;

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

/* Peek a byte directly from CGA video memory at 0xB8000:loc */
uint8_t cga_peek_byte(struct cga_context *cga, int loc)
{
	uint8_t byte = 0;
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);
	assert(cga->surface != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	byte |= *pixel++ << 6;
	byte |= *pixel++ << 4;
	byte |= *pixel++ << 2;
	byte |= *pixel++ << 0;

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);

	return byte;
}

void cga_poke_bytes(struct cga_context *cga, int loc, uint8_t byte, size_t count)
{
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);
	assert(cga->surface != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	while (count-- != 0) {
		*pixel++ = (byte >> 6) & 0x3;
		*pixel++ = (byte >> 4) & 0x3;
		*pixel++ = (byte >> 2) & 0x3;
		*pixel++ = (byte >> 0) & 0x3;
	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

#if 0
void cga_peek_bytes(struct cga_context *cga, int loc, uint8_t *bytes, size_t count)
{
	size_t i, maxcount;
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	/* Make sure we will not overindex the pixel array. */
	maxcount = cga->surface->pitch * cga->surface->h + pixel -
	           (uint8_t *)cga->surface->pixels;

	for (i = 0; i < count && i < maxcount; i++) {
		bytes[i] |= __cga_map_from_hw_palette(cga, *pixel++) << 6;
		bytes[i] |= __cga_map_from_hw_palette(cga, *pixel++) << 4;
		bytes[i] |= __cga_map_from_hw_palette(cga, *pixel++) << 2;
		bytes[i] |= __cga_map_from_hw_palette(cga, *pixel++) << 0;
	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}
#endif

/* Poke a word directly to CGA video memory in 0xB8000:loc */
void cga_poke_word(struct cga_context *cga, int loc, uint16_t word)
{
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);
	assert(cga->surface != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	*pixel++ = (word >>  6) & 0x3;
	*pixel++ = (word >>  4) & 0x3;
	*pixel++ = (word >>  2) & 0x3;
	*pixel++ = (word >>  0) & 0x3;
	*pixel++ = (word >> 14) & 0x3;
	*pixel++ = (word >> 12) & 0x3;
	*pixel++ = (word >> 10) & 0x3;
	*pixel++ = (word >>  8) & 0x3;

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

void cga_poke_words(struct cga_context *cga, int loc, uint16_t word, size_t count)
{
	uint8_t *pixel;
	int x, y;

	assert(cga != NULL);
	assert(cga->surface != NULL);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	/* Convert CGA offset to a coordinate tuple. */
	__cga_map_location(cga, loc, &x, &y);
	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	while (count-- != 0) {
		*pixel++ = (word >>  6) & 0x3;
		*pixel++ = (word >>  4) & 0x3;
		*pixel++ = (word >>  2) & 0x3;
		*pixel++ = (word >>  0) & 0x3;
		*pixel++ = (word >> 14) & 0x3;
		*pixel++ = (word >> 12) & 0x3;
		*pixel++ = (word >> 10) & 0x3;
		*pixel++ = (word >>  8) & 0x3;
	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

/* Poke a raw image directly to CGA video memory at 0xB8000:loc */
void
cga_poke_image(struct cga_context *cga, struct cga_image_raw *image, int loc)
{
	int x, y;

	__cga_map_location(cga, loc, &x, &y);
	__surface_poke_image(cga->surface, image, x, y);
}

#if 0
/* Peek a sprite directly from CGA video memory at 0xB800:loc */
void cga_peek_sprite(struct cga_context *cga, struct cga_sprite *sprite, int loc)
{
	int x, y;

	assert(cga != NULL);
	assert(sprite != NULL);

	__cga_map_location(cga, loc, &x, &y);
	cga_read_sprite(cga, sprite, x, y);
}

void cga_poke_overlay(struct cga_context *cga, struct cga_sprite *sprite, int loc)
{
	int x, y;

	assert(cga != NULL);
	assert(sprite != NULL);

	__cga_map_location(cga, loc, &x, &y);
	cga_draw_overlay(cga, sprite, x, y);
}
#endif

void cga_floodfill(struct cga_context *cga, int color)
{
	uint8_t *start, *end;

	assert(cga != NULL);
	assert(cga->surface != NULL);
	assert(color >= 0 && color <= 3);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

        start = cga->surface->pixels;
        end = start + cga->surface->pitch * cga->surface->h;

        while (start < end)
		*start++ = (uint8_t)color;

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

#if 0
/* XXX: only clips negative 'x' */
void cga_draw_sprite(struct cga_context *cga, struct cga_sprite *sprite, int x, int y)
{
	uint8_t *data = sprite->data;
	int height = sprite->height;
	int width = sprite->width;
	uint8_t *pixel;
	int clip_x;
	int i, j;

	assert(x + width < INT_MAX);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	for (i = 0; i < height; i++) {
		for (j = 0, clip_x = x; j < width / 4; j++, data++, pixel += 4) {
			if (clip_x++ >= 0)
				pixel[0] = __cga_map_to_hw_palette(cga, (*data >> 6) & 0x3);
			if (clip_x++ >= 0)
				pixel[1] = __cga_map_to_hw_palette(cga, (*data >> 4) & 0x3);
			if (clip_x++ >= 0)
				pixel[2] = __cga_map_to_hw_palette(cga, (*data >> 2) & 0x3);
			if (clip_x++ >= 0)
				pixel[3] = __cga_map_to_hw_palette(cga, (*data >> 0) & 0x3);
		}

#if 0
		/* Handle remainder bits */
		switch(width % 4) {
		case 3:
			*pixel++ = __cga_map_to_hw_palette(cga, (*data >> 6) & 0x3);
		case 2:
			*pixel++ = __cga_map_to_hw_palette(cga, (*data >> 4) & 0x3);
		case 1:
			*pixel++ = __cga_map_to_hw_palette(cga, (*data >> 2) & 0x3);
		}
#endif
		pixel += cga->surface->pitch -
		         width * cga->surface->format->BytesPerPixel;

	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}

void cga_read_sprite(struct cga_context *cga, struct cga_sprite *sprite, int x, int y)
{
	uint8_t *data = sprite->data;
	int height = sprite->height;
	int width = sprite->width;
	uint8_t tail = 0;
	uint8_t *pixel;
	int i, j;

	assert(cga != NULL);
	assert(sprite != NULL);
	assert(sprite->size == sprite->height * sprite->width / 4);

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	pixel = cga->surface->pixels + x + y * cga->surface->pitch;

	for (i = 0; i < height; i++) {
		for (j = 0; j < width / 4; j++) {
		for (j = 0, clip_x = x; j < width / 4; j++, data++, pixel += 4) {
			*data = __cga_map_from_hw_palette(cga, *pixel++) << 6;
			*data |= __cga_map_from_hw_palette(cga, *pixel++) << 4;
			*data |= __cga_map_from_hw_palette(cga, *pixel++) << 2;
			*data |= __cga_map_from_hw_palette(cga, *pixel++) << 0;
			data++;
                }

		/* Handle remainder bits */
		switch(width % 4) {
		case 3:
			tail |= __cga_map_from_hw_palette(cga, *pixel++) << 6;
		case 2:
			tail |= __cga_map_from_hw_palette(cga, *pixel++) << 4;
		case 1:
			tail |= __cga_map_from_hw_palette(cga, *pixel++) << 2;
			*data = tail;
		}
		pixel += cga->surface->pitch -
		         width * cga->surface->format->BytesPerPixel;
	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}
#endif

int cga_image_load(struct cga_image *image, struct cga_image_raw *raw)
{
	SDL_Surface *surface;

	assert(raw);
	assert(image);

	surface = SDL_CreateRGBSurface(SDL_HWSURFACE, raw->width,
	                               raw->height, 8, 0, 0, 0, 0);
	if (surface == NULL)
		return -1;

	/* Poke the raw image data to the new surface. */
	__surface_poke_image(surface, raw, 0, 0);

	/* Initialize the image structure. */
	image->surface = surface;

	return 0;
}

int
cga_image_blit(struct cga_context *cga, struct cga_image *image, int x, int y)
{
	SDL_Rect rect;
	int ret;

	assert(cga != NULL);
	assert(cga->surface != NULL);
	assert(image != NULL);
	assert(image->surface != NULL);

	rect.x = x;
	rect.y = y;
	rect.w = image->surface->w;
	rect.h = image->surface->h;

	/* We reinitialize the palette of the image before blitting it, as a
	 * different palette could have been chosen for the CGA surface.
	 */
	ret = __surface_set_palette(image->surface, cga->background_color,
	                            cga->palette, cga->intensity);
	if (ret != 1)
		return -1;

	return SDL_BlitSurface(image->surface, NULL, cga->surface, &rect);
}

int cga_sprite_load(struct cga_sprite *sprite, ...)
{
	struct cga_image_raw *image;
	SDL_Surface *surface;
	int width, height;
	int frames = 1;
	va_list ap;

	assert(sprite);

	va_start(ap, sprite);
	/* The first argument sets some defaults */
	image = va_arg(ap, struct cga_image_raw *);
	assert(image != NULL);
	width = image->width, height = image->height;

	/* Count the number of frames we have. */
	while ( (image = va_arg(ap, struct cga_image_raw *)) != NULL) {
		assert(image->height == height);
		assert(image->width == width);

		frames++;
	}
	va_end(ap);

	/* Create a new surface with the right dimensions. */
	surface = SDL_CreateRGBSurface(SDL_HWSURFACE, width * frames,
	                               height, 8, 0, 0, 0, 0);
	if (surface == NULL)
		return -1;

	/* Poke all data to the newly allocated surface. */
	frames = 0;
	va_start(ap, sprite);
	while ( (image = va_arg(ap, struct cga_image_raw *)) != NULL) {
		__surface_poke_image(surface, image, width * frames, 0);
		frames++;
	}
	va_end(ap);

	sprite->surface = surface;
	sprite->frames = frames;
	sprite->x = sprite->y = 0;
	sprite->height = height;
	sprite->width = width;

	return 0;
}

int
cga_sprite_set_colorkey(struct cga_sprite *sprite, int color)
{
	assert(sprite != NULL);
	assert(color >= 0 && color <= 3);

	return SDL_SetColorKey(sprite->surface, SDL_SRCCOLORKEY, color);
}

int
cga_sprite_blit(struct cga_context *cga,
                struct cga_sprite *sprite, int frame, int x, int y)
{
	SDL_Rect sprite_rect, cga_rect;
	int ret;

	assert(cga != NULL);
	assert(cga->surface != NULL);
	assert(sprite != NULL);
	assert(sprite->surface != NULL);
	assert(frame >= 0 && frame < sprite->frames);

	sprite_rect.x = frame * sprite->width;
	sprite_rect.y = 0;
	sprite_rect.w = sprite->width;
	sprite_rect.h = sprite->height;

	cga_rect.x = x;
	cga_rect.y = y;

	/* We reinitialize the palette of the image before blitting it, as a
	 * different palette could have been chosen for the CGA surface.
	 */
	ret = __surface_set_palette(sprite->surface, cga->background_color,
	                            cga->palette, cga->intensity);
	if (ret != 1)
		return -1;

	return SDL_BlitSurface(sprite->surface, &sprite_rect,
	                       cga->surface, &cga_rect);
}

int
cga_sprite_blit_all(struct cga_context *cga, struct cga_sprite *sprite, int x, int y)
{
	SDL_Rect rect;
	int ret;

	assert(cga != NULL);
	assert(cga->surface != NULL);
	assert(sprite != NULL);
	assert(sprite->surface != NULL);

	rect.x = x;
	rect.y = y;
	rect.w = sprite->surface->w;
	rect.h = sprite->surface->h;

	/* We reinitialize the palette of the image before blitting it, as a
	 * different palette could have been chosen for the CGA surface.
	 */
	ret = __surface_set_palette(sprite->surface, cga->background_color,
	                            cga->palette, cga->intensity);
	if (ret != 1)
		return -1;

	return SDL_BlitSurface(sprite->surface, NULL, cga->surface, &rect);
}

#if 0
void cga_draw_overlay(struct cga_context *cga, struct cga_sprite *sprite, int x, int y)
{
	uint8_t *pixel = cga->surface->pixels + x + y * cga->surface->pitch;
	uint8_t *data = sprite->data;
	int i, j;

	if (SDL_MUSTLOCK(cga->surface))
		SDL_LockSurface(cga->surface);

	for (i = 0; i < sprite->height; i++) {
		for (j = 0; j < sprite->width / 4; j++) {
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 6) & 0x3);
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 4) & 0x3);
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 2) & 0x3);
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 0) & 0x3);
			data++;
                }

		/* Handle remainder bits */
		switch(sprite->width % 4) {
		case 3:
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 6) & 0x3);
		case 2:
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 4) & 0x3);
		case 1:
			*pixel++ &= __cga_map_to_hw_palette(cga, (*data >> 2) & 0x3);
		}
		pixel += cga->surface->pitch -
			sprite->width * cga->surface->format->BytesPerPixel;
	}

	if (SDL_MUSTLOCK(cga->surface))
		SDL_UnlockSurface(cga->surface);
}
#endif

/* Set the CGA intensity bit */
int cga_set_intensity(struct cga_context *cga, int intensity)
{
	assert(intensity == CGA_INTENSITY_NORMAL ||
	       intensity == CGA_INTENSITY_HIGH);

	cga->intensity = intensity;
	return __cga_set_palette(cga) == 1 ? 0 : -1;
}

/* Set the use of CGA palette 0 or 1 */
int cga_set_palette(struct cga_context *cga, int palette)
{
	assert(cga != NULL);
	assert(cga->surface != NULL);
	assert(palette == CGA_PALETTE_0 || palette == CGA_PALETTE_1);

	cga->palette = palette;
	return __cga_set_palette(cga) == 1 ? 0 : -1;
}

#if 0
/* Set the CGA background color.
 * Please note that this can be any of the 16 values in the CGA hardware
 * palette.
 */
void cga_set_background_color(struct cga_context *cga, int color)
{
	assert(color >= 0 && color <= 15);

	if (cga->background_color != color) {
		cga->background_color = color;
		__cga_load_fonts(cga);
	}
}
#endif

/* Can cause a surface reload! */
void cga_font_set_thick(struct cga_context *cga)
{
	if (cga->font_type != CGA_FONT_THICK) {
		cga->font_type = CGA_FONT_THICK;
		__cga_load_fonts(cga);
	}
}

/* Can cause a surface reload! */
void cga_font_set_thin(struct cga_context *cga)
{
	if (cga->font_type != CGA_FONT_THIN) {
		cga->font_type = CGA_FONT_THIN;
		__cga_load_fonts(cga);
	}
}

/* Can cause a surface reload! */
void cga_font_set_color(struct cga_context *cga, int color)
{
	assert(color >= 0 && color <= 3);

	if (cga->font_color != color) {
		cga->font_color = color;
		__cga_load_fonts(cga);
	}
}

void cga_set_cursor_position(struct cga_context *cga, int x, int y)
{
	cga->cursor_pos.x = x * 8;
	cga->cursor_pos.y = y * 8;
}

/* corresponds with int 10h 0x0e */
int cga_write_char(struct cga_context *cga, SDL_Surface *screen, const char ch)
{
	int ret;
	SDL_Rect font = { .w = 8, .h = 8 };

	font.x = (ch % 16) * 8;
	font.y = (ch / 16) * 8;

	ret = SDL_BlitSurface(cga->fonts, &font, screen, &cga->cursor_pos);
	if (ret == 0) {
		cga->cursor_pos.y += ((cga->cursor_pos.x + 8) / screen->w) * 8;
		cga->cursor_pos.x = (cga->cursor_pos.x + 8) % screen->w;
	}

	return ret;
}

/* XXX: refactor later */
int cga_write_text(struct cga_context *cga, SDL_Surface *screen, const char *text)
{
	size_t i, max = strlen(text);

	for (i = 0; i < max; i++)
		if (cga_write_char(cga, screen, text[i]) != 0)
			break;

	return i == max;
}

#if 0
/* Replicated from hexdump.c to prevent additional dependencies when
 * reusing this CGA module.
 */
int cga_print_sprite(struct cga_sprite *sprite)
{
        int ret = 0;
	size_t i;

        for (i = 0; i < sprite->size; i++) {
                ret += printf("%.2x", sprite->data[i]);

                if (i % 16 == 15) {
                        ret += printf("\n");
                } else if (i + 1 != sprite->size) {
                        ret += printf(" ");

                        if (i % 16 == 7)
                                ret += printf(" ");
                }
        }

        return ret;
}
#endif

void __cga_load_fonts(struct cga_context *cga) {}

#if 0
void __cga_load_fonts(struct cga_context *cga)
{
	uint8_t font_pixel;
	uint8_t *fontset;
	int i, x, y;

	switch(cga->font_type) {
	case CGA_FONT_THIN:
		fontset = cga_font_thin;
		break;
	case CGA_FONT_THICK:
		fontset = cga_font_thick;
		break;
	default:
		fprintf(stderr, "Unknown CGA font set\n");
		exit(EXIT_FAILURE);
	}

	/* Load the entire fontset in the foreground color specified. */
	font_pixel = cga->font_color;

	if (SDL_MUSTLOCK(cga->fonts))
		SDL_LockSurface(cga->fonts);

	for (i = y = 0; y < 128; y++) {
		for (x = 0; x < 128; i++, x++) {
			if (fontset[i / 8] >> (7 - x % 8) & 1)
				SDL_SetPixel(cga->fonts, x, y, font_pixel);
			else
				/* XXX: assumption, is this correct? */
				SDL_SetPixel(cga->fonts, x, y, cga->background_color);
		}
	}

	if (SDL_MUSTLOCK(cga->fonts))
		SDL_UnlockSurface(cga->fonts);
}
#endif

/* CGA textmode consists of two fontsets, one having thick characters and one
 * having thin characters.  Both fontsets consist of 256 8x8 tiles.
 * The following data is a trivial 128x128 bitmap representing these fontsets.
 */
uint8_t cga_font_thick[] = {
  0x00, 0x7e, 0x7e, 0x6c, 0x10, 0x38, 0x10, 0x00, 0xff, 0x00, 0xff, 0x0f,
  0x3c, 0x3f, 0x7f, 0x18, 0x00, 0x81, 0xff, 0xfe, 0x38, 0x7c, 0x10, 0x00,
  0xff, 0x3c, 0xc3, 0x07, 0x66, 0x33, 0x63, 0xdb, 0x00, 0xa5, 0xdb, 0xfe,
  0x7c, 0x38, 0x38, 0x18, 0xe7, 0x66, 0x99, 0x0f, 0x66, 0x3f, 0x7f, 0x3c,
  0x00, 0x81, 0xff, 0xfe, 0xfe, 0xfe, 0x7c, 0x3c, 0xc3, 0x42, 0xbd, 0x7d,
  0x66, 0x30, 0x63, 0xe7, 0x00, 0xbd, 0xc3, 0x7c, 0x7c, 0xfe, 0xfe, 0x3c,
  0xc3, 0x42, 0xbd, 0xcc, 0x3c, 0x30, 0x63, 0xe7, 0x00, 0x99, 0xe7, 0x38,
  0x38, 0xd6, 0x7c, 0x18, 0xe7, 0x66, 0x99, 0xcc, 0x18, 0x70, 0x67, 0x3c,
  0x00, 0x81, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0xff, 0x3c, 0xc3, 0xcc,
  0x7e, 0xf0, 0xe6, 0xdb, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x38, 0x38, 0x00,
  0xff, 0x00, 0xff, 0x78, 0x18, 0xe0, 0xc0, 0x18, 0x80, 0x02, 0x18, 0x66,
  0x7f, 0x3e, 0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xe0, 0x0e, 0x3c, 0x66, 0xdb, 0x63, 0x00, 0x3c, 0x3c, 0x18, 0x18, 0x30,
  0x00, 0x24, 0x18, 0xff, 0xf8, 0x3e, 0x7e, 0x66, 0xdb, 0x38, 0x00, 0x7e,
  0x7e, 0x18, 0x0c, 0x60, 0xc0, 0x66, 0x3c, 0xff, 0xfe, 0xfe, 0x18, 0x66,
  0x7b, 0x6c, 0x00, 0x18, 0x18, 0x18, 0xfe, 0xfe, 0xc0, 0xff, 0x7e, 0x7e,
  0xf8, 0x3e, 0x18, 0x66, 0x1b, 0x6c, 0x7e, 0x7e, 0x18, 0x7e, 0x0c, 0x60,
  0xc0, 0x66, 0xff, 0x3c, 0xe0, 0x0e, 0x7e, 0x00, 0x1b, 0x38, 0x7e, 0x3c,
  0x18, 0x3c, 0x18, 0x30, 0xfe, 0x24, 0xff, 0x18, 0x80, 0x02, 0x3c, 0x66,
  0x1b, 0xcc, 0x7e, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x00, 0x00, 0x78, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x6c, 0x6c, 0x30, 0x00, 0x38, 0x60,
  0x18, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x78, 0x6c, 0x6c,
  0x7c, 0xc6, 0x6c, 0x60, 0x30, 0x30, 0x66, 0x30, 0x00, 0x00, 0x00, 0x0c,
  0x00, 0x78, 0x6c, 0xfe, 0xc0, 0xcc, 0x38, 0xc0, 0x60, 0x18, 0x3c, 0x30,
  0x00, 0x00, 0x00, 0x18, 0x00, 0x30, 0x00, 0x6c, 0x78, 0x18, 0x76, 0x00,
  0x60, 0x18, 0xff, 0xfc, 0x00, 0xfc, 0x00, 0x30, 0x00, 0x30, 0x00, 0xfe,
  0x0c, 0x30, 0xdc, 0x00, 0x60, 0x18, 0x3c, 0x30, 0x00, 0x00, 0x00, 0x60,
  0x00, 0x00, 0x00, 0x6c, 0xf8, 0x66, 0xcc, 0x00, 0x30, 0x30, 0x66, 0x30,
  0x30, 0x00, 0x30, 0xc0, 0x00, 0x30, 0x00, 0x6c, 0x30, 0xc6, 0x76, 0x00,
  0x18, 0x60, 0x00, 0x00, 0x30, 0x00, 0x30, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
  0x7c, 0x30, 0x78, 0x78, 0x1c, 0xfc, 0x38, 0xfc, 0x78, 0x78, 0x00, 0x00,
  0x18, 0x00, 0x60, 0x78, 0xc6, 0x70, 0xcc, 0xcc, 0x3c, 0xc0, 0x60, 0xcc,
  0xcc, 0xcc, 0x30, 0x30, 0x30, 0x00, 0x30, 0xcc, 0xce, 0x30, 0x0c, 0x0c,
  0x6c, 0xf8, 0xc0, 0x0c, 0xcc, 0xcc, 0x30, 0x30, 0x60, 0xfc, 0x18, 0x0c,
  0xde, 0x30, 0x38, 0x38, 0xcc, 0x0c, 0xf8, 0x18, 0x78, 0x7c, 0x00, 0x00,
  0xc0, 0x00, 0x0c, 0x18, 0xf6, 0x30, 0x60, 0x0c, 0xfe, 0x0c, 0xcc, 0x30,
  0xcc, 0x0c, 0x00, 0x00, 0x60, 0x00, 0x18, 0x30, 0xe6, 0x30, 0xcc, 0xcc,
  0x0c, 0xcc, 0xcc, 0x30, 0xcc, 0x18, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x00,
  0x7c, 0xfc, 0xfc, 0x78, 0x1e, 0x78, 0x78, 0x30, 0x78, 0x70, 0x30, 0x30,
  0x18, 0x00, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x30, 0xfc, 0x3c,
  0xf8, 0xfe, 0xfe, 0x3c, 0xcc, 0x78, 0x1e, 0xe6, 0xf0, 0xc6, 0xc6, 0x38,
  0xc6, 0x78, 0x66, 0x66, 0x6c, 0x62, 0x62, 0x66, 0xcc, 0x30, 0x0c, 0x66,
  0x60, 0xee, 0xe6, 0x6c, 0xde, 0xcc, 0x66, 0xc0, 0x66, 0x68, 0x68, 0xc0,
  0xcc, 0x30, 0x0c, 0x6c, 0x60, 0xfe, 0xf6, 0xc6, 0xde, 0xcc, 0x7c, 0xc0,
  0x66, 0x78, 0x78, 0xc0, 0xfc, 0x30, 0x0c, 0x78, 0x60, 0xfe, 0xde, 0xc6,
  0xde, 0xfc, 0x66, 0xc0, 0x66, 0x68, 0x68, 0xce, 0xcc, 0x30, 0xcc, 0x6c,
  0x62, 0xd6, 0xce, 0xc6, 0xc0, 0xcc, 0x66, 0x66, 0x6c, 0x62, 0x60, 0x66,
  0xcc, 0x30, 0xcc, 0x66, 0x66, 0xc6, 0xc6, 0x6c, 0x78, 0xcc, 0xfc, 0x3c,
  0xf8, 0xfe, 0xf0, 0x3e, 0xcc, 0x78, 0x78, 0xe6, 0xfe, 0xc6, 0xc6, 0x38,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xfc, 0x78, 0xfc, 0x78, 0xfc, 0xcc, 0xcc, 0xc6,
  0xc6, 0xcc, 0xfe, 0x78, 0xc0, 0x78, 0x10, 0x00, 0x66, 0xcc, 0x66, 0xcc,
  0xb4, 0xcc, 0xcc, 0xc6, 0xc6, 0xcc, 0xc6, 0x60, 0x60, 0x18, 0x38, 0x00,
  0x66, 0xcc, 0x66, 0x60, 0x30, 0xcc, 0xcc, 0xc6, 0x6c, 0xcc, 0x8c, 0x60,
  0x30, 0x18, 0x6c, 0x00, 0x7c, 0xcc, 0x7c, 0x30, 0x30, 0xcc, 0xcc, 0xd6,
  0x38, 0x78, 0x18, 0x60, 0x18, 0x18, 0xc6, 0x00, 0x60, 0xdc, 0x6c, 0x18,
  0x30, 0xcc, 0xcc, 0xfe, 0x38, 0x30, 0x32, 0x60, 0x0c, 0x18, 0x00, 0x00,
  0x60, 0x78, 0x66, 0xcc, 0x30, 0xcc, 0x78, 0xee, 0x6c, 0x30, 0x66, 0x60,
  0x06, 0x18, 0x00, 0x00, 0xf0, 0x1c, 0xe6, 0x78, 0x78, 0xfc, 0x30, 0xc6,
  0xc6, 0x78, 0xfe, 0x78, 0x02, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
  0x30, 0x00, 0xe0, 0x00, 0x1c, 0x00, 0x38, 0x00, 0xe0, 0x30, 0x0c, 0xe0,
  0x70, 0x00, 0x00, 0x00, 0x30, 0x00, 0x60, 0x00, 0x0c, 0x00, 0x6c, 0x00,
  0x60, 0x00, 0x00, 0x60, 0x30, 0x00, 0x00, 0x00, 0x18, 0x78, 0x60, 0x78,
  0x0c, 0x78, 0x60, 0x76, 0x6c, 0x70, 0x0c, 0x66, 0x30, 0xcc, 0xf8, 0x78,
  0x00, 0x0c, 0x7c, 0xcc, 0x7c, 0xcc, 0xf0, 0xcc, 0x76, 0x30, 0x0c, 0x6c,
  0x30, 0xfe, 0xcc, 0xcc, 0x00, 0x7c, 0x66, 0xc0, 0xcc, 0xfc, 0x60, 0xcc,
  0x66, 0x30, 0x0c, 0x78, 0x30, 0xfe, 0xcc, 0xcc, 0x00, 0xcc, 0x66, 0xcc,
  0xcc, 0xc0, 0x60, 0x7c, 0x66, 0x30, 0xcc, 0x6c, 0x30, 0xd6, 0xcc, 0xcc,
  0x00, 0x76, 0xdc, 0x78, 0x76, 0x78, 0xf0, 0x0c, 0xe6, 0x78, 0xcc, 0xe6,
  0x78, 0xc6, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8,
  0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x18, 0xe0, 0x76, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30,
  0x18, 0x30, 0xdc, 0x10, 0xdc, 0x76, 0xdc, 0x7c, 0x7c, 0xcc, 0xcc, 0xc6,
  0xc6, 0xcc, 0xfc, 0x30, 0x18, 0x30, 0x00, 0x38, 0x66, 0xcc, 0x76, 0xc0,
  0x30, 0xcc, 0xcc, 0xd6, 0x6c, 0xcc, 0x98, 0xe0, 0x00, 0x1c, 0x00, 0x6c,
  0x66, 0xcc, 0x66, 0x78, 0x30, 0xcc, 0xcc, 0xfe, 0x38, 0xcc, 0x30, 0x30,
  0x18, 0x30, 0x00, 0xc6, 0x7c, 0x7c, 0x60, 0x0c, 0x34, 0xcc, 0x78, 0xfe,
  0x6c, 0x7c, 0x64, 0x30, 0x18, 0x30, 0x00, 0xc6, 0x60, 0x0c, 0xf0, 0xf8,
  0x18, 0x76, 0x30, 0x6c, 0xc6, 0x0c, 0xfc, 0x1c, 0x18, 0xe0, 0x00, 0xfe,
  0xf0, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x1c, 0x7e, 0xcc, 0xe0, 0x30, 0x00,
  0x7e, 0xcc, 0xe0, 0xcc, 0x7c, 0xe0, 0xc6, 0x30, 0xcc, 0xcc, 0x00, 0xc3,
  0x00, 0x00, 0x30, 0x00, 0xc3, 0x00, 0x00, 0x00, 0xc6, 0x00, 0x38, 0x30,
  0xc0, 0x00, 0x78, 0x3c, 0x78, 0x78, 0x78, 0x78, 0x3c, 0x78, 0x78, 0x70,
  0x38, 0x70, 0x6c, 0x00, 0xcc, 0xcc, 0xcc, 0x06, 0x0c, 0x0c, 0x0c, 0xc0,
  0x66, 0xcc, 0xcc, 0x30, 0x18, 0x30, 0xc6, 0x78, 0x78, 0xcc, 0xfc, 0x3e,
  0x7c, 0x7c, 0x7c, 0xc0, 0x7e, 0xfc, 0xfc, 0x30, 0x18, 0x30, 0xfe, 0xcc,
  0x18, 0xcc, 0xc0, 0x66, 0xcc, 0xcc, 0xcc, 0x78, 0x60, 0xc0, 0xc0, 0x30,
  0x18, 0x30, 0xc6, 0xfc, 0x0c, 0x7e, 0x78, 0x3f, 0x7e, 0x7e, 0x7e, 0x0c,
  0x3c, 0x78, 0x78, 0x78, 0x3c, 0x78, 0xc6, 0xcc, 0x78, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x1c, 0x00, 0x3e, 0x78, 0x00, 0x00, 0x78, 0x00, 0x00, 0xc3, 0xcc, 0x18,
  0x38, 0xcc, 0xf8, 0x0e, 0x00, 0x00, 0x6c, 0xcc, 0xcc, 0xe0, 0xcc, 0xe0,
  0xcc, 0x18, 0x00, 0x18, 0x6c, 0xcc, 0xcc, 0x1b, 0xfc, 0x7f, 0xcc, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0xcc, 0x7e, 0x64, 0x78, 0xcc, 0x18,
  0x60, 0x0c, 0xfe, 0x78, 0x78, 0x78, 0xcc, 0xcc, 0xcc, 0x66, 0xcc, 0xc0,
  0xf0, 0xfc, 0xfa, 0x3c, 0x78, 0x7f, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
  0xcc, 0x66, 0xcc, 0xc0, 0x60, 0x30, 0xc6, 0x18, 0x60, 0xcc, 0xcc, 0xcc,
  0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x3c, 0xcc, 0x7e, 0xe6, 0xfc, 0xcf, 0x18,
  0xfc, 0x7f, 0xce, 0x78, 0x78, 0x78, 0x7e, 0x7e, 0x0c, 0x18, 0x78, 0x18,
  0xfc, 0x30, 0xc6, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xf8, 0x00, 0x00, 0x18, 0x00, 0x30, 0xc7, 0x70, 0x1c, 0x38, 0x00, 0x00,
  0x00, 0xfc, 0x3c, 0x38, 0x30, 0x00, 0x00, 0xc3, 0xc3, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x1c, 0x1c, 0xf8, 0x00, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0xc6,
  0xc6, 0x18, 0x33, 0xcc, 0x78, 0x70, 0x00, 0x00, 0x00, 0xcc, 0x6c, 0x6c,
  0x30, 0x00, 0x00, 0xcc, 0xcc, 0x00, 0x66, 0x66, 0x0c, 0x30, 0x78, 0xcc,
  0xf8, 0xec, 0x3e, 0x38, 0x60, 0xfc, 0xfc, 0xde, 0xdb, 0x18, 0xcc, 0x33,
  0x7c, 0x30, 0xcc, 0xcc, 0xcc, 0xfc, 0x00, 0x00, 0xc0, 0xc0, 0x0c, 0x33,
  0x37, 0x18, 0x66, 0x66, 0xcc, 0x30, 0xcc, 0xcc, 0xcc, 0xdc, 0x7e, 0x7c,
  0xcc, 0xc0, 0x0c, 0x66, 0x6f, 0x18, 0x33, 0xcc, 0x7e, 0x78, 0x78, 0x7e,
  0xcc, 0xcc, 0x00, 0x00, 0x78, 0x00, 0x00, 0xcc, 0xcf, 0x18, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f,
  0x03, 0x00, 0x00, 0x00, 0x22, 0x55, 0xdb, 0x18, 0x18, 0x18, 0x36, 0x00,
  0x00, 0x36, 0x36, 0x00, 0x36, 0x36, 0x18, 0x00, 0x88, 0xaa, 0x77, 0x18,
  0x18, 0x18, 0x36, 0x00, 0x00, 0x36, 0x36, 0x00, 0x36, 0x36, 0x18, 0x00,
  0x22, 0x55, 0xdb, 0x18, 0x18, 0xf8, 0x36, 0x00, 0xf8, 0xf6, 0x36, 0xfe,
  0xf6, 0x36, 0xf8, 0x00, 0x88, 0xaa, 0xee, 0x18, 0x18, 0x18, 0x36, 0x00,
  0x18, 0x06, 0x36, 0x06, 0x06, 0x36, 0x18, 0x00, 0x22, 0x55, 0xdb, 0x18,
  0xf8, 0xf8, 0xf6, 0xfe, 0xf8, 0xf6, 0x36, 0xf6, 0xfe, 0xfe, 0xf8, 0xf8,
  0x88, 0xaa, 0x77, 0x18, 0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36,
  0x00, 0x00, 0x00, 0x18, 0x22, 0x55, 0xdb, 0x18, 0x18, 0x18, 0x36, 0x36,
  0x18, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x18, 0x88, 0xaa, 0xee, 0x18,
  0x18, 0x18, 0x36, 0x36, 0x18, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x18,
  0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x36, 0x00, 0x36, 0x00,
  0x36, 0x00, 0x36, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36,
  0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x36, 0x18, 0x18, 0x18, 0x00, 0x18,
  0x00, 0x18, 0x1f, 0x36, 0x37, 0x3f, 0xf7, 0xff, 0x37, 0xff, 0xf7, 0xff,
  0x18, 0x18, 0x00, 0x18, 0x00, 0x18, 0x18, 0x36, 0x30, 0x30, 0x00, 0x00,
  0x30, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0x37,
  0x3f, 0x37, 0xff, 0xf7, 0x37, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x18, 0x18,
  0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36, 0x36, 0x00, 0x36, 0x00,
  0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36, 0x00, 0x36, 0x00, 0x36,
  0x36, 0x00, 0x36, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x36,
  0x00, 0x36, 0x00, 0x36, 0x36, 0x00, 0x36, 0x00, 0x36, 0x00, 0x00, 0x36,
  0x18, 0x00, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff,
  0x36, 0x00, 0x00, 0x36, 0x18, 0x00, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff,
  0x00, 0xf0, 0x0f, 0xff, 0x36, 0xff, 0x00, 0x36, 0x1f, 0x1f, 0x00, 0x36,
  0xff, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff, 0x36, 0x00, 0x00, 0x36,
  0x18, 0x18, 0x00, 0x36, 0x18, 0x18, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff,
  0xff, 0xff, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0xff, 0xf8, 0x1f, 0xff,
  0xff, 0xf0, 0x0f, 0x00, 0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36,
  0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x18, 0x36, 0x00,
  0x00, 0x18, 0x36, 0x36, 0x18, 0x00, 0x18, 0xff, 0xff, 0xf0, 0x0f, 0x00,
  0x00, 0x18, 0x36, 0x00, 0x00, 0x18, 0x36, 0x36, 0x18, 0x00, 0x18, 0xff,
  0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00,
  0xfc, 0x38, 0x38, 0x1c, 0x00, 0x06, 0x38, 0x78, 0x00, 0x78, 0xfc, 0xfe,
  0xcc, 0x00, 0x66, 0x76, 0x30, 0x6c, 0x6c, 0x30, 0x00, 0x0c, 0x60, 0xcc,
  0x76, 0xcc, 0xcc, 0x6c, 0x60, 0x7e, 0x66, 0xdc, 0x78, 0xc6, 0xc6, 0x18,
  0x7e, 0x7e, 0xc0, 0xcc, 0xdc, 0xf8, 0xc0, 0x6c, 0x30, 0xd8, 0x66, 0x18,
  0xcc, 0xfe, 0xc6, 0x7c, 0xdb, 0xdb, 0xf8, 0xcc, 0xc8, 0xcc, 0xc0, 0x6c,
  0x60, 0xd8, 0x66, 0x18, 0xcc, 0xc6, 0x6c, 0xcc, 0xdb, 0xdb, 0xc0, 0xcc,
  0xdc, 0xf8, 0xc0, 0x6c, 0xcc, 0xd8, 0x7c, 0x18, 0x78, 0x6c, 0x6c, 0xcc,
  0x7e, 0x7e, 0x60, 0xcc, 0x76, 0xc0, 0xc0, 0x6c, 0xfc, 0x70, 0x60, 0x18,
  0x30, 0x38, 0xee, 0x78, 0x00, 0x60, 0x38, 0xcc, 0x00, 0xc0, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00,
  0x00, 0x30, 0x60, 0x18, 0x0e, 0x18, 0x30, 0x00, 0x38, 0x00, 0x00, 0x0f,
  0x78, 0x70, 0x00, 0x00, 0xfc, 0x30, 0x30, 0x30, 0x1b, 0x18, 0x30, 0x76,
  0x6c, 0x00, 0x00, 0x0c, 0x6c, 0x18, 0x00, 0x00, 0x00, 0xfc, 0x18, 0x60,
  0x1b, 0x18, 0x00, 0xdc, 0x6c, 0x00, 0x00, 0x0c, 0x6c, 0x30, 0x3c, 0x00,
  0xfc, 0x30, 0x30, 0x30, 0x18, 0x18, 0xfc, 0x00, 0x38, 0x18, 0x00, 0x0c,
  0x6c, 0x60, 0x3c, 0x00, 0x00, 0x30, 0x60, 0x18, 0x18, 0x18, 0x00, 0x76,
  0x00, 0x18, 0x18, 0xec, 0x6c, 0x78, 0x3c, 0x00, 0xfc, 0x00, 0x00, 0x00,
  0x18, 0xd8, 0x30, 0xdc, 0x00, 0x00, 0x00, 0x6c, 0x00, 0x00, 0x3c, 0x00,
  0x00, 0xfc, 0xfc, 0xfc, 0x18, 0xd8, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3c,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x70, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00
};

uint8_t cga_font_thin[] = {
  0x00, 0x7e, 0x7e, 0x6c, 0x10, 0x38, 0x10, 0x00, 0xff, 0x00, 0xff, 0x0f,
  0x3c, 0x3f, 0x3f, 0x18, 0x00, 0x81, 0xff, 0xfe, 0x38, 0x7c, 0x10, 0x00,
  0xff, 0x3c, 0xc3, 0x03, 0x42, 0x21, 0x21, 0xdb, 0x00, 0xa5, 0xdb, 0xfe,
  0x7c, 0x38, 0x38, 0x18, 0xe7, 0x66, 0x99, 0x05, 0x42, 0x3f, 0x3f, 0x3c,
  0x00, 0x81, 0xff, 0xfe, 0xfe, 0xfe, 0x7c, 0x3c, 0xc3, 0x42, 0xbd, 0x7d,
  0x42, 0x20, 0x21, 0xe7, 0x00, 0xbd, 0xc3, 0x7c, 0x7c, 0xfe, 0xfe, 0x3c,
  0xc3, 0x42, 0xbd, 0x84, 0x3c, 0x20, 0x23, 0xe7, 0x00, 0x99, 0xe7, 0x38,
  0x38, 0xd6, 0x7c, 0x18, 0xe7, 0x66, 0x99, 0x84, 0x18, 0x60, 0x67, 0x3c,
  0x00, 0x81, 0xff, 0x10, 0x10, 0x10, 0x10, 0x00, 0xff, 0x3c, 0xc3, 0x84,
  0x7e, 0xe0, 0xe6, 0xdb, 0x00, 0x7e, 0x7e, 0x00, 0x00, 0x38, 0x38, 0x00,
  0xff, 0x00, 0xff, 0x78, 0x18, 0xc0, 0xc0, 0x18, 0x80, 0x02, 0x18, 0x24,
  0x7f, 0x3e, 0x00, 0x18, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xe0, 0x0e, 0x3c, 0x24, 0x92, 0x63, 0x00, 0x3c, 0x38, 0x10, 0x18, 0x30,
  0x00, 0x24, 0x10, 0xfe, 0xf8, 0x3e, 0x7e, 0x24, 0x92, 0x38, 0x00, 0x7e,
  0x7c, 0x10, 0x0c, 0x60, 0x40, 0x66, 0x38, 0xfe, 0xfe, 0xfe, 0x18, 0x24,
  0x72, 0x44, 0x00, 0x18, 0x54, 0x54, 0xfe, 0xfe, 0x40, 0xff, 0x7c, 0x7c,
  0xf8, 0x3e, 0x18, 0x24, 0x12, 0x44, 0x7e, 0x7e, 0x10, 0x7c, 0x0c, 0x60,
  0x40, 0x66, 0xfe, 0x38, 0xe0, 0x0e, 0x7e, 0x00, 0x12, 0x38, 0x7e, 0x3c,
  0x10, 0x38, 0x18, 0x30, 0x7e, 0x24, 0xfe, 0x10, 0x80, 0x02, 0x3c, 0x24,
  0x12, 0xcc, 0x7e, 0x18, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x00, 0x00, 0x78, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x24, 0x18, 0x00, 0x30, 0x10,
  0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x24, 0x24,
  0x3e, 0x62, 0x48, 0x10, 0x20, 0x10, 0x44, 0x10, 0x00, 0x00, 0x00, 0x02,
  0x00, 0x38, 0x24, 0x7e, 0x40, 0x64, 0x30, 0x20, 0x40, 0x08, 0x38, 0x10,
  0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x24, 0x3c, 0x08, 0x56, 0x00,
  0x40, 0x08, 0xfe, 0x7c, 0x00, 0x7e, 0x00, 0x08, 0x00, 0x10, 0x00, 0x7e,
  0x02, 0x10, 0x88, 0x00, 0x40, 0x08, 0x38, 0x10, 0x00, 0x00, 0x00, 0x10,
  0x00, 0x00, 0x00, 0x24, 0x7c, 0x26, 0x88, 0x00, 0x20, 0x10, 0x44, 0x10,
  0x10, 0x00, 0x10, 0x20, 0x00, 0x10, 0x00, 0x24, 0x18, 0x46, 0x76, 0x00,
  0x10, 0x20, 0x00, 0x00, 0x10, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
  0x3c, 0x10, 0x3c, 0x3c, 0x08, 0x7e, 0x1c, 0x7e, 0x3c, 0x3c, 0x00, 0x00,
  0x08, 0x00, 0x10, 0x3c, 0x42, 0x30, 0x42, 0x42, 0x18, 0x40, 0x20, 0x42,
  0x42, 0x42, 0x10, 0x10, 0x10, 0x00, 0x08, 0x42, 0x46, 0x50, 0x02, 0x02,
  0x28, 0x7c, 0x40, 0x04, 0x42, 0x42, 0x10, 0x10, 0x20, 0x7e, 0x04, 0x02,
  0x4a, 0x10, 0x0c, 0x1c, 0x48, 0x02, 0x7c, 0x08, 0x3c, 0x3e, 0x00, 0x00,
  0x40, 0x00, 0x02, 0x04, 0x52, 0x10, 0x30, 0x02, 0xfe, 0x02, 0x42, 0x10,
  0x42, 0x02, 0x00, 0x00, 0x20, 0x00, 0x04, 0x08, 0x62, 0x10, 0x42, 0x42,
  0x08, 0x42, 0x42, 0x10, 0x42, 0x04, 0x10, 0x10, 0x10, 0x7e, 0x08, 0x00,
  0x3c, 0x7c, 0x7e, 0x3c, 0x1c, 0x3c, 0x3c, 0x10, 0x3c, 0x38, 0x10, 0x10,
  0x08, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x18, 0x7c, 0x1c,
  0x78, 0x7e, 0x7e, 0x1c, 0x42, 0x38, 0x0e, 0x62, 0x70, 0x63, 0x62, 0x18,
  0x42, 0x24, 0x22, 0x22, 0x24, 0x22, 0x22, 0x22, 0x42, 0x10, 0x04, 0x24,
  0x20, 0x55, 0x52, 0x24, 0x5e, 0x42, 0x22, 0x40, 0x22, 0x28, 0x28, 0x40,
  0x42, 0x10, 0x04, 0x28, 0x20, 0x49, 0x4a, 0x42, 0x52, 0x42, 0x3c, 0x40,
  0x22, 0x38, 0x38, 0x40, 0x7e, 0x10, 0x04, 0x30, 0x20, 0x41, 0x46, 0x42,
  0x5e, 0x7e, 0x22, 0x40, 0x22, 0x28, 0x28, 0x4e, 0x42, 0x10, 0x44, 0x28,
  0x20, 0x41, 0x42, 0x42, 0x40, 0x42, 0x22, 0x22, 0x24, 0x22, 0x20, 0x22,
  0x42, 0x10, 0x44, 0x24, 0x22, 0x41, 0x42, 0x24, 0x3c, 0x42, 0x7c, 0x1c,
  0x78, 0x7e, 0x70, 0x1e, 0x42, 0x38, 0x38, 0x63, 0x7e, 0x41, 0x42, 0x18,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x7c, 0x3c, 0x7c, 0x3c, 0x7f, 0x42, 0x41, 0x41,
  0x41, 0x41, 0x7f, 0x78, 0x80, 0x78, 0x10, 0x00, 0x22, 0x42, 0x22, 0x42,
  0x49, 0x42, 0x41, 0x41, 0x22, 0x22, 0x42, 0x40, 0x40, 0x08, 0x28, 0x00,
  0x22, 0x42, 0x22, 0x40, 0x08, 0x42, 0x41, 0x41, 0x14, 0x14, 0x04, 0x40,
  0x20, 0x08, 0x44, 0x00, 0x3c, 0x42, 0x3c, 0x3c, 0x08, 0x42, 0x41, 0x49,
  0x08, 0x08, 0x08, 0x40, 0x10, 0x08, 0x82, 0x00, 0x20, 0x4a, 0x28, 0x02,
  0x08, 0x42, 0x22, 0x49, 0x14, 0x08, 0x10, 0x40, 0x08, 0x08, 0x00, 0x00,
  0x20, 0x3c, 0x24, 0x42, 0x08, 0x42, 0x14, 0x49, 0x22, 0x08, 0x21, 0x40,
  0x04, 0x08, 0x00, 0x00, 0x70, 0x03, 0x72, 0x3c, 0x1c, 0x3c, 0x08, 0x36,
  0x41, 0x1c, 0x7f, 0x78, 0x02, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
  0x10, 0x00, 0x60, 0x00, 0x06, 0x00, 0x0c, 0x00, 0x60, 0x10, 0x02, 0x60,
  0x30, 0x00, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 0x02, 0x00, 0x12, 0x00,
  0x20, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x08, 0x3c, 0x20, 0x3c,
  0x02, 0x3c, 0x10, 0x3d, 0x2c, 0x30, 0x06, 0x24, 0x10, 0x76, 0x5c, 0x3c,
  0x00, 0x02, 0x2e, 0x42, 0x3a, 0x42, 0x38, 0x42, 0x32, 0x10, 0x02, 0x28,
  0x10, 0x49, 0x62, 0x42, 0x00, 0x3e, 0x31, 0x40, 0x46, 0x7e, 0x10, 0x42,
  0x22, 0x10, 0x02, 0x30, 0x10, 0x49, 0x42, 0x42, 0x00, 0x42, 0x31, 0x42,
  0x46, 0x40, 0x10, 0x3e, 0x22, 0x10, 0x42, 0x28, 0x10, 0x49, 0x42, 0x42,
  0x00, 0x3f, 0x2e, 0x3c, 0x3b, 0x3c, 0x38, 0x02, 0x62, 0x38, 0x42, 0x26,
  0x38, 0x49, 0x42, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c,
  0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x10, 0x30, 0x32, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
  0x10, 0x08, 0x4c, 0x08, 0x6c, 0x36, 0x6c, 0x3e, 0x7c, 0x42, 0x41, 0x41,
  0x44, 0x42, 0x7c, 0x10, 0x10, 0x08, 0x00, 0x14, 0x32, 0x4c, 0x32, 0x40,
  0x10, 0x42, 0x41, 0x49, 0x28, 0x42, 0x08, 0x60, 0x00, 0x06, 0x00, 0x22,
  0x32, 0x4c, 0x22, 0x3c, 0x10, 0x42, 0x22, 0x49, 0x10, 0x42, 0x10, 0x10,
  0x10, 0x08, 0x00, 0x41, 0x2c, 0x34, 0x20, 0x02, 0x12, 0x46, 0x14, 0x49,
  0x28, 0x3e, 0x20, 0x10, 0x10, 0x08, 0x00, 0x41, 0x20, 0x04, 0x70, 0x7c,
  0x0c, 0x3a, 0x08, 0x36, 0x44, 0x02, 0x7c, 0x0c, 0x10, 0x30, 0x00, 0x7f,
  0x70, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x0c, 0x3c, 0x42, 0x30, 0x10, 0x00,
  0x3c, 0x42, 0x30, 0x24, 0x7c, 0x30, 0x42, 0x18, 0x42, 0x44, 0x00, 0x42,
  0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x82, 0x00, 0x18, 0x18,
  0x40, 0x00, 0x3c, 0x38, 0x38, 0x38, 0x38, 0x3c, 0x3c, 0x3c, 0x3c, 0x18,
  0x30, 0x18, 0x24, 0x00, 0x42, 0x44, 0x42, 0x04, 0x04, 0x04, 0x04, 0x40,
  0x42, 0x42, 0x42, 0x08, 0x10, 0x08, 0x42, 0x3c, 0x3c, 0x44, 0x7e, 0x3c,
  0x3c, 0x3c, 0x3c, 0x40, 0x7e, 0x7e, 0x7e, 0x08, 0x10, 0x08, 0x7e, 0x42,
  0x0c, 0x44, 0x40, 0x44, 0x44, 0x44, 0x44, 0x3c, 0x40, 0x40, 0x40, 0x08,
  0x10, 0x08, 0x42, 0x7e, 0x02, 0x3e, 0x3c, 0x3e, 0x3e, 0x3e, 0x3e, 0x06,
  0x3c, 0x3c, 0x3c, 0x1c, 0x38, 0x1c, 0x42, 0x42, 0x3c, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x00, 0x1f, 0x18, 0x00, 0x20, 0x18, 0x20, 0x00, 0x42, 0x42, 0x08,
  0x18, 0x44, 0xf8, 0x1c, 0x00, 0x00, 0x24, 0x24, 0x42, 0x10, 0x24, 0x10,
  0x42, 0x18, 0x00, 0x08, 0x24, 0x28, 0x4c, 0x12, 0x7c, 0x33, 0x44, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x42, 0x3e, 0x20, 0x7c, 0x78, 0x10,
  0x20, 0x0c, 0x7f, 0x3c, 0x3c, 0x3c, 0x42, 0x42, 0x42, 0x42, 0x42, 0x40,
  0x70, 0x10, 0x44, 0x7c, 0x38, 0x3f, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42,
  0x42, 0x42, 0x42, 0x40, 0x20, 0x7c, 0x4f, 0x10, 0x20, 0x44, 0x44, 0x42,
  0x42, 0x42, 0x42, 0x42, 0x3e, 0x24, 0x42, 0x3e, 0x42, 0x10, 0x44, 0x10,
  0x7c, 0x3b, 0x47, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x02, 0x18, 0x3c, 0x08,
  0x7c, 0x10, 0x45, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x3c, 0x00, 0x00, 0x08, 0x00, 0x00, 0xe6, 0x60, 0x0c, 0x0c, 0x04, 0x00,
  0x32, 0x34, 0x3c, 0x38, 0x10, 0x00, 0x00, 0x42, 0x42, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x08, 0x04, 0x4c, 0x4c, 0x44, 0x44, 0x00, 0x00, 0x00, 0xc4,
  0xc4, 0x10, 0x12, 0x48, 0x38, 0x18, 0x00, 0x08, 0x00, 0x00, 0x44, 0x44,
  0x10, 0x00, 0x00, 0x48, 0x4a, 0x00, 0x24, 0x24, 0x04, 0x08, 0x3c, 0x42,
  0x7c, 0x62, 0x3e, 0x38, 0x20, 0x7e, 0x7e, 0xf6, 0xf6, 0x10, 0x48, 0x12,
  0x3c, 0x08, 0x42, 0x42, 0x42, 0x52, 0x00, 0x00, 0x40, 0x40, 0x02, 0x29,
  0x2a, 0x10, 0x24, 0x24, 0x44, 0x08, 0x42, 0x42, 0x42, 0x4a, 0x7e, 0x7c,
  0x42, 0x40, 0x02, 0x43, 0x5f, 0x10, 0x12, 0x48, 0x3e, 0x1c, 0x3c, 0x3c,
  0x42, 0x46, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x8c, 0x82, 0x10, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f,
  0x02, 0x00, 0x00, 0x00, 0x22, 0x55, 0xdb, 0x10, 0x10, 0x10, 0x14, 0x00,
  0x00, 0x14, 0x14, 0x00, 0x14, 0x14, 0x10, 0x00, 0x88, 0xaa, 0x77, 0x10,
  0x10, 0x10, 0x14, 0x00, 0x00, 0x14, 0x14, 0x00, 0x14, 0x14, 0x10, 0x00,
  0x22, 0x55, 0xdb, 0x10, 0x10, 0xf0, 0x14, 0x00, 0xf0, 0xf4, 0x14, 0xfc,
  0xf4, 0x14, 0xf0, 0x00, 0x88, 0xaa, 0xee, 0x10, 0x10, 0x10, 0x14, 0x00,
  0x10, 0x04, 0x14, 0x04, 0x04, 0x14, 0x10, 0x00, 0x22, 0x55, 0xdb, 0x10,
  0xf0, 0xf0, 0xf4, 0xfc, 0xf0, 0xf4, 0x14, 0xf4, 0xfc, 0xfc, 0xf0, 0xf0,
  0x88, 0xaa, 0x77, 0x10, 0x10, 0x10, 0x14, 0x14, 0x10, 0x14, 0x14, 0x14,
  0x00, 0x00, 0x00, 0x10, 0x22, 0x55, 0xdb, 0x10, 0x10, 0x10, 0x14, 0x14,
  0x10, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x10, 0x88, 0xaa, 0xee, 0x10,
  0x10, 0x10, 0x14, 0x14, 0x10, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x10,
  0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14, 0x14, 0x00, 0x14, 0x00,
  0x14, 0x00, 0x14, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14,
  0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x10, 0x10, 0x10, 0x00, 0x10,
  0x00, 0x10, 0x1f, 0x14, 0x17, 0x1f, 0xf7, 0xff, 0x17, 0xff, 0xf7, 0xff,
  0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14, 0x10, 0x10, 0x00, 0x00,
  0x10, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0x1f, 0xff, 0xff, 0x1f, 0x17,
  0x1f, 0x17, 0xff, 0xf7, 0x17, 0xff, 0xf7, 0xff, 0x00, 0x00, 0x10, 0x10,
  0x00, 0x10, 0x10, 0x14, 0x00, 0x14, 0x00, 0x14, 0x14, 0x00, 0x14, 0x00,
  0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x14, 0x00, 0x14, 0x00, 0x14,
  0x14, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x14,
  0x00, 0x14, 0x00, 0x14, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x00, 0x14,
  0x10, 0x00, 0x00, 0x14, 0x10, 0x10, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff,
  0x14, 0x00, 0x00, 0x14, 0x10, 0x00, 0x00, 0x14, 0x10, 0x10, 0x00, 0xff,
  0x00, 0xf0, 0x0f, 0xff, 0x14, 0xff, 0x00, 0x14, 0x1f, 0x1f, 0x00, 0x14,
  0xff, 0x10, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff, 0x14, 0x00, 0x00, 0x14,
  0x10, 0x10, 0x00, 0x14, 0x10, 0x10, 0x00, 0xff, 0x00, 0xf0, 0x0f, 0xff,
  0xff, 0xff, 0xff, 0x1f, 0x1f, 0x1f, 0x1f, 0xff, 0xff, 0xf0, 0x1f, 0xff,
  0xff, 0xf0, 0x0f, 0x00, 0x00, 0x10, 0x14, 0x00, 0x00, 0x10, 0x14, 0x14,
  0x10, 0x00, 0x10, 0xff, 0xff, 0xf0, 0x0f, 0x00, 0x00, 0x10, 0x14, 0x00,
  0x00, 0x10, 0x14, 0x14, 0x10, 0x00, 0x10, 0xff, 0xff, 0xf0, 0x0f, 0x00,
  0x00, 0x10, 0x14, 0x00, 0x00, 0x10, 0x14, 0x14, 0x10, 0x00, 0x10, 0xff,
  0xff, 0xf0, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x7c, 0x18, 0x18, 0x1c, 0x00, 0x02, 0x0c, 0x3c, 0x00, 0x3c, 0x7e, 0x3f,
  0x42, 0x00, 0x44, 0x33, 0x10, 0x24, 0x24, 0x20, 0x62, 0x04, 0x10, 0x42,
  0x31, 0x42, 0x42, 0x54, 0x20, 0x3e, 0x44, 0x4c, 0x38, 0x42, 0x42, 0x18,
  0x95, 0x3c, 0x20, 0x42, 0x4a, 0x7c, 0x40, 0x14, 0x18, 0x48, 0x44, 0x08,
  0x44, 0x7e, 0x42, 0x3c, 0x89, 0x4a, 0x3c, 0x42, 0x44, 0x42, 0x40, 0x14,
  0x20, 0x48, 0x7a, 0x08, 0x44, 0x42, 0x24, 0x42, 0x95, 0x52, 0x20, 0x42,
  0x4a, 0x7c, 0x40, 0x14, 0x42, 0x48, 0x40, 0x08, 0x38, 0x24, 0x24, 0x42,
  0x62, 0x3c, 0x10, 0x42, 0x31, 0x40, 0x40, 0x14, 0x7e, 0x30, 0x40, 0x08,
  0x10, 0x18, 0x66, 0x3c, 0x00, 0x40, 0x0c, 0x42, 0x00, 0x40, 0x00, 0x00,
  0x00, 0x00, 0x80, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
  0x00, 0x10, 0x10, 0x08, 0x0c, 0x10, 0x18, 0x00, 0x30, 0x00, 0x00, 0x0f,
  0x78, 0x30, 0x00, 0x00, 0x7e, 0x10, 0x08, 0x10, 0x12, 0x10, 0x18, 0x32,
  0x48, 0x00, 0x00, 0x08, 0x44, 0x48, 0x00, 0x00, 0x00, 0x7c, 0x04, 0x20,
  0x12, 0x10, 0x00, 0x4c, 0x48, 0x00, 0x00, 0x08, 0x44, 0x10, 0x3c, 0x00,
  0x7e, 0x10, 0x08, 0x10, 0x10, 0x10, 0x7e, 0x00, 0x30, 0x18, 0x00, 0x08,
  0x44, 0x20, 0x3c, 0x00, 0x00, 0x10, 0x10, 0x08, 0x10, 0x10, 0x00, 0x32,
  0x00, 0x18, 0x18, 0x08, 0x44, 0x78, 0x3c, 0x00, 0x7e, 0x00, 0x00, 0x00,
  0x10, 0x90, 0x18, 0x4c, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x3c, 0x00,
  0x00, 0x7c, 0x7e, 0x7e, 0x10, 0x90, 0x18, 0x00, 0x00, 0x00, 0x00, 0x28,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x60, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00
};
